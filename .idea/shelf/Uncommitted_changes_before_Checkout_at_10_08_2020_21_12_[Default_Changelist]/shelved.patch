Index: Server/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\r\n    id \"java\"\r\n    id \"org.jetbrains.kotlin.jvm\" version \"1.3.72\"\r\n    id \"application\"\r\n}\r\n\r\nsourceCompatibility = 1.8\r\ntargetCompatibility = 1.8\r\n\r\nmainClassName = 'core.Server'\r\n\r\n\r\nrepositories {\r\n    flatDir {\r\n        dirs 'libs'\r\n    }\r\n    mavenCentral()\r\n}\r\n\r\ndependencies {\r\n    implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk8\"\r\n    implementation name: 'clientlibs'\r\n    implementation name: 'guava-18.0'\r\n    implementation name: 'javassist-3.20.0-GA'\r\n    implementation name: 'mysql-connector-java-5.1.30-bin'\r\n    implementation name: 'reflections-0.9.10'\r\n    implementation \"com.googlecode.json-simple:json-simple:1.1.1\"\r\n    implementation \"io.github.classgraph:classgraph:4.8.62\"\r\n    implementation \"org.jetbrains.kotlin:kotlin-reflect\"\r\n}\r\n\r\n\r\njar {\r\n    archiveBaseName = 'server'\r\n    archiveVersion =  '1.0.0'\r\n}\r\n\r\nsourceSets {\r\n    main.java.srcDirs = ['src/main/java/Server']\r\n    main.kotlin.srcDirs = ['src/main/java/Server']\r\n}\r\n\r\ncompileKotlin {\r\n    kotlinOptions {\r\n        jvmTarget = \"1.8\"\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Server/build.gradle	(revision 0eaf93649d735b04d0ae8059a6b71fa9a98f6cb8)
+++ Server/build.gradle	(date 1597090309734)
@@ -45,3 +45,15 @@
         jvmTarget = "1.8"
     }
 }
+
+sourceSets {
+    main.java.srcDirs = ['src/main/java/Server']
+    main.kotlin.srcDirs = ['src/main/java/Server']
+}
+
+compileKotlin {
+    kotlinOptions {
+        jvmTarget = "1.8"
+    }
+    mavenCentral()
+}
Index: Server/src/main/java/Server/plugin/skill/farming/compost/CompostManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package plugin.skill.farming.compost;\r\n\r\nimport core.game.container.Container;\r\nimport core.game.node.entity.player.Player;\r\nimport core.game.node.entity.player.info.login.SavingModule;\r\nimport core.game.node.item.Item;\r\nimport core.game.node.object.GameObject;\r\nimport org.json.simple.JSONArray;\r\nimport org.json.simple.JSONObject;\r\n\r\nimport java.nio.ByteBuffer;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * Represents the managing class of compost bins.\r\n * @author 'Vexia\r\n * @version 1.0\r\n */\r\npublic final class CompostManager implements SavingModule {\r\n\r\n\t/**\r\n\t * Represents the list of compost bins.\r\n\t */\r\n\tprivate final List<CompostBin> bins = new ArrayList<>();\r\n\r\n\t/**\r\n\t * Constructs a new {@code CompostBinManager} {@code Object}.\r\n\t */\r\n\tpublic CompostManager() {\r\n\t\t/**\r\n\t\t * empty.\r\n\t\t */\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void save(ByteBuffer buffer) {\r\n\t\tbuffer.put((byte) bins.size());\r\n\t\tfor (CompostBin bin : bins) {\r\n\t\t\tbuffer.putInt(bin.getWrapperId());\r\n\t\t\tif (bin.getTimeStamp() != 0L) {\r\n\t\t\t\tbuffer.put((byte) 1);\r\n\t\t\t\tbuffer.putLong(bin.getTimeStamp());\r\n\t\t\t}\r\n\t\t\tif (bin.getContainer().itemCount() != 0) {\r\n\t\t\t\tbuffer.put((byte) 2);\r\n\t\t\t\tbin.getContainer().save(buffer);\r\n\t\t\t}\r\n\t\t\tbuffer.put((byte) 0);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void parse(JSONArray data){\r\n\t\tfor(int i = 0; i < data.size(); i++){\r\n\t\t\tJSONObject b = (JSONObject) data.get(i);\r\n\r\n\t\t\tCompostBin bin = new CompostBin(Integer.parseInt(b.get(\"wrapperId\").toString()));\r\n\t\t\tbin.setTimeStamp(Long.parseLong(b.getOrDefault(\"timeStamp\",0L).toString()));\r\n\t\t\tbin.compostLevel = Integer.parseInt(b.getOrDefault(\"compostLevel\",0).toString());\r\n\t\t\tbin.getContainer().parse((JSONArray) b.getOrDefault(\"compostContainer\", new JSONArray()));\r\n\t\t\tbins.add(bin);\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void parse(ByteBuffer buffer) {\r\n\t\tint size = buffer.get();\r\n\t\tint opcode;\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tCompostBin bin = new CompostBin(buffer.getInt());\r\n\t\t\twhile ((opcode = buffer.get() & 0xFF) != 0) {\r\n\t\t\t\tswitch (opcode) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tbin.setTimeStamp(buffer.getLong());\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tbin.getContainer().parse(buffer);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbins.add(bin);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to fill a compost.\r\n\t * @param player the player.\r\n\t * @param object the object.\r\n\t * @param option the option.\r\n\t * @param delay the delay\r\n\t */\r\n\tpublic void fill(final Player player, final Item item, final GameObject object, String option, int delay) {\r\n\t\tCompostBin bin = getBin(object);\r\n\t\tif (option.equals(\"bin\")) {\r\n\t\t\tbin.fillBin(player, item, delay);\r\n\t\t} else {\r\n\t\t\tbin.fillBucket(player, delay);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the compost bin by the object wrapper.\r\n\t * @param object the object.\r\n\t * @return the wrapper.\r\n\t */\r\n\tpublic CompostBin getBin(final GameObject object) {\r\n\t\tfinal GameObject wrapper = object.getWrapper();\r\n\t\tfor (CompostBin bin : getBins()) {\r\n\t\t\tif (bin.getWrapperId() == wrapper.getId()) {\r\n\t\t\t\treturn bin;\r\n\t\t\t}\r\n\t\t}\r\n\t\tCompostBin bin = new CompostBin(object.getWrapper().getId());\r\n\t\tbins.add(bin);\r\n\t\treturn bin;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the bins.\r\n\t * @return The bins.\r\n\t */\r\n\tpublic List<CompostBin> getBins() {\r\n\t\treturn bins;\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Server/src/main/java/Server/plugin/skill/farming/compost/CompostManager.java	(revision 0eaf93649d735b04d0ae8059a6b71fa9a98f6cb8)
+++ Server/src/main/java/Server/plugin/skill/farming/compost/CompostManager.java	(date 1597090310332)
@@ -62,6 +62,18 @@
 		}
 	}
 
+	public void parse(JSONArray data){
+		for(int i = 0; i < data.size(); i++){
+			JSONObject b = (JSONObject) data.get(i);
+
+			CompostBin bin = new CompostBin(Integer.parseInt(b.get("wrapperId").toString()));
+			bin.setTimeStamp(Long.parseLong(b.getOrDefault("timeStamp",0L).toString()));
+			bin.compostLevel = Integer.parseInt(b.getOrDefault("compostLevel",0).toString());
+			bin.getContainer().parse((JSONArray) b.getOrDefault("compostContainer", new JSONArray()));
+			bins.add(bin);
+		}
+	}
+
 	@Override
 	public void parse(ByteBuffer buffer) {
 		int size = buffer.get();
Index: Server/src/main/java/Server/core/game/node/entity/player/link/appearance/Appearance.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package core.game.node.entity.player.link.appearance;\r\n\r\nimport core.cache.def.impl.ItemDefinition;\r\nimport core.cache.def.impl.NPCDefinition;\r\nimport core.game.container.impl.EquipmentContainer;\r\nimport core.game.node.entity.combat.equipment.WeaponInterface;\r\nimport core.game.node.entity.impl.Animator.Priority;\r\nimport core.game.node.entity.player.Player;\r\nimport core.game.node.entity.player.info.login.SavingModule;\r\nimport core.game.node.item.Item;\r\nimport core.game.system.config.ItemConfigParser;\r\nimport core.game.world.update.flag.context.Animation;\r\nimport core.game.world.update.flag.player.AppearanceFlag;\r\nimport org.json.simple.JSONArray;\r\nimport org.json.simple.JSONObject;\r\n\r\nimport java.nio.ByteBuffer;\r\n\r\n/**\r\n * Represents an appearance managing class of a player.\r\n * @author Emperor\r\n * @author Vexia\r\n */\r\npublic final class Appearance implements SavingModule {\r\n\r\n\t/**\r\n\t * Represents the player instance.\r\n\t */\r\n\tprivate final Player player;\r\n\r\n\t/**\r\n\t * Represents the cached animations.\r\n\t */\r\n\tprivate final int[] animationCache = new int[] { AppearanceCache.STAND_ANIM, AppearanceCache.STAND_TURN_ANIM, AppearanceCache.WALK_ANIM, AppearanceCache.TURN_180_AIM, AppearanceCache.TURN_90_CW, AppearanceCache.TUNR_90_CWW, AppearanceCache.RUN_ANIM };\r\n\t\r\n\t/**\r\n\t * Represents the cached icons.\r\n\t */\r\n\tprivate final int[] iconCache = new int[] { -1, -1 };\r\n\r\n\t/**\r\n\t * Represents the shown body parts.\r\n\t */\r\n\tprivate final int[] bodyParts = new int[14];\r\n\r\n\t/**\r\n\t * Represents the cached body parts (default male).\r\n\t */\r\n\tprivate BodyPart[] appearanceCache = Gender.MALE.generateCache();\r\n\r\n\t/**\r\n\t * Represents the gender of a player.\r\n\t */\r\n\tprivate Gender gender = Gender.MALE;\r\n\r\n\t/**\r\n\t * Represents the npc id to represent if not -1.\r\n\t */\r\n\tprivate int npcId = -1;\r\n\t\r\n\t/**\r\n\t * The render animation id.\r\n\t */\r\n\tprivate int renderAnimationId = 1426;\r\n\r\n\t/**\r\n\t * If the player is riding a mining cart.\r\n\t */\r\n\tprivate boolean ridingMinecart;\r\n\r\n\t/**\r\n\t * Constructs a new {@code Appearance} {@code Object}.\r\n\t * @param player the player of this appearance.\r\n\t */\r\n\tpublic Appearance(final Player player) {\r\n\t\tthis.player = player;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void save(ByteBuffer buffer) {\r\n\t\tbuffer.put(gender.toByte());\r\n\t\tfor (int i = 0; i < appearanceCache.length; i++) {\r\n\t\t\tappearanceCache[i].save(buffer);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic void parse(JSONObject appearance){\r\n\t\tgender = gender.asByte(Byte.parseByte(appearance.get(\"gender\").toString()));\r\n\t\tJSONArray appCache = (JSONArray) appearance.get(\"appearance_cache\");\r\n\t\tfor(int i = 0; i < appearanceCache.length; i++){\r\n\t\t\t(appearanceCache[i]).parse((JSONObject) appCache.get(i));\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void parse(ByteBuffer buffer) {\r\n\t\tgender = gender.asByte(buffer.get());\r\n\t\tfor (int i = 0; i < appearanceCache.length; i++) {\r\n\t\t\tappearanceCache[i].parse(buffer);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Transforms the player into an NPC.\r\n\t * @param id The NPC id.\r\n\t */\r\n\tpublic void transformNPC(int id) {\r\n\t\tthis.npcId = id;\r\n\t\tsetAnimations();\r\n\t\tif (id == -1) {\r\n\t\t\tplayer.setSize(1);\r\n\t\t\tAnimation[] anims = WeaponInterface.DEFAULT_ANIMS;\r\n\t\t\tif (player.getEquipment().get(3) != null) {\r\n\t\t\t\tanims = player.getEquipment().get(3).getDefinition().getConfiguration(ItemConfigParser.ATTACK_ANIMS, anims);\r\n\t\t\t}\r\n\t\t\tint index = player.getSettings().getAttackStyleIndex();\r\n\t\t\tif (index < 0 || index >= anims.length) {\r\n\t\t\t\tindex = 0;\r\n\t\t\t}\r\n\t\t\tplayer.getProperties().setAttackAnimation(anims[index]);\r\n\t\t\tplayer.getProperties().setDefenceAnimation(new Animation(404));\r\n\t\t\tplayer.getProperties().setDeathAnimation(new Animation(9055, Priority.HIGH));\r\n\t\t} else {\r\n\t\t\tNPCDefinition def = NPCDefinition.forId(id);\r\n\t\t\tplayer.setSize(def.getSize());\r\n\t\t\tif (def.getCombatAnimation(0) != null) {\r\n\t\t\t\tplayer.getProperties().setAttackAnimation(def.getCombatAnimation(0));\r\n\t\t\t}\r\n\t\t\tif (def.getCombatAnimation(3) != null) {\r\n\t\t\t\tplayer.getProperties().setDefenceAnimation(def.getCombatAnimation(3));\r\n\t\t\t}\r\n\t\t\tif (def.getCombatAnimation(4) != null) {\r\n\t\t\t\tplayer.getProperties().setDeathAnimation(def.getCombatAnimation(4));\r\n\t\t\t}\r\n\t\t}\r\n\t\tsync();\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the rendering animations.\r\n\t * @param player The player.\r\n\t */\r\n\tpublic void setAnimations() {\r\n\t\tif (npcId == -1) {\r\n\t\t\tItem weapon = player.getEquipment().get(3);\r\n\t\t\tif (isRidingMinecart()) {\r\n\t\t\t\tthis.setRidingMinecart(false);\r\n\t\t\t}\r\n\t\t\tif (weapon == null || weapon.getDefinition().getConfiguration(ItemConfigParser.WALK_ANIM, null) == null) {\r\n\t\t\t\tsetDefaultAnimations();\r\n\t\t\t} else {\r\n\t\t\t\tItemDefinition def = weapon.getDefinition();\r\n\t\t\t\tsetStandAnimation(def.getConfiguration(ItemConfigParser.STAND_ANIM, 0x328));\r\n\t\t\t\tsetStandTurnAnimation(def.getConfiguration(ItemConfigParser.STAND_TURN_ANIM, 0x337));\r\n\t\t\t\tsetWalkAnimation(def.getConfiguration(ItemConfigParser.WALK_ANIM, 0x333));\r\n\t\t\t\tsetRunAnimation(def.getConfiguration(ItemConfigParser.RUN_ANIM, 0x338));\r\n\t\t\t\tsetTurn180(def.getConfiguration(ItemConfigParser.TURN180_ANIM, 0x334));\r\n\t\t\t\tsetTurn90cw(def.getConfiguration(ItemConfigParser.TURN90CW_ANIM, 0x335));\r\n\t\t\t\tsetTurn90ccw(def.getConfiguration(ItemConfigParser.TURN90CCW_ANIM, 0x336));\r\n\t\t\t\trenderAnimationId = def.getRenderAnimationId();\r\n\t\t\t}\r\n\t\t\tif (weapon != null && weapon.getId() == 12842) {\r\n\t\t\t\tsetStandAnimation(8964);\r\n\t\t\t\tsetWalkAnimation(8961);\r\n\t\t\t\tsetRunAnimation(8963);\r\n\t\t\t\tsetTurn180(8963);\r\n\t\t\t\tsetTurn90ccw(8963);\r\n\t\t\t\tsetTurn90cw(8963);\r\n\t\t\t\tsetStandTurnAnimation(8963);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tNPCDefinition def = NPCDefinition.forId(npcId);\r\n\t\t\trenderAnimationId = def.getRenderAnimationId();\r\n\t\t\tsetStandAnimation(def.getStandAnimation());\r\n\t\t\tint turn = def.getTurnAnimation();\r\n\t\t\tif (turn < 1) {\r\n\t\t\t\tturn = def.getWalkAnimation();\r\n\t\t\t}\r\n\t\t\tsetStandTurnAnimation(turn);\r\n\t\t\tsetWalkAnimation(def.getWalkAnimation());\r\n\t\t\tsetRunAnimation(def.getWalkAnimation());\r\n\t\t\tif (def.getTurn180Animation() > 0) {\r\n\t\t\t\tsetTurn180(def.getTurn180Animation());\r\n\t\t\t} else {\r\n\t\t\t\tsetTurn180(turn);\r\n\t\t\t}\r\n\t\t\tif (def.getTurnCWAnimation() > 0) {\r\n\t\t\t\tsetTurn90cw(def.getTurnCWAnimation());\r\n\t\t\t} else {\r\n\t\t\t\tsetTurn90cw(turn);\r\n\t\t\t}\r\n\t\t\tif (def.getTurnCCWAnimation() > 0) {\r\n\t\t\t\tsetTurn90ccw(def.getTurnCCWAnimation());\r\n\t\t\t} else {\r\n\t\t\t\tsetTurn90ccw(turn);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the animations.\r\n\t * @param animation the animation.\r\n\t */\r\n\tpublic void setAnimations(Animation anim) {\r\n\t\trenderAnimationId = anim.getId();\r\n\t\tsync();\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to sync this appearance with the client.\r\n\t */\r\n\tpublic void sync() {\r\n\t\tplayer.getUpdateMasks().register(new AppearanceFlag(player));\r\n\t}\r\n\r\n\t/**\r\n\t * Copies the appearance.\r\n\t * @param appearance The appearance to copy from.\r\n\t */\r\n\tpublic void copy(Appearance appearance) {\r\n\t\tgender = appearance.gender;\r\n\t\tfor (int i = 0; i < appearanceCache.length; i++) {\r\n\t\t\tappearanceCache[i] = appearance.appearanceCache[i];\r\n\t\t}\r\n\t\tfor (int i = 0; i < animationCache.length; i++) {\r\n\t\t\tanimationCache[i] = appearance.animationCache[i];\r\n\t\t}\r\n\t\trenderAnimationId = appearance.renderAnimationId;\r\n\t}\r\n\r\n\t/**\r\n\t * Draws an item on a body part.\r\n\t * @param part The body part.\r\n\t * @param item The item to draw.\r\n\t */\r\n\tpublic void drawItem(int part, Item item) {\r\n\t\tthis.bodyParts[part] = item.getDefinition().getEquipId() + 0x8000;\r\n\t}\r\n\r\n\t/**\r\n\t * Draws clothing on a body part.\r\n\t * @param part The body part.\r\n\t * @param clothesId The clothes id.\r\n\t */\r\n\tpublic void drawClothes(int part, int clothesId) {\r\n\t\tthis.bodyParts[part] = clothesId + 0x100;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears a body part.\r\n\t * @param part The part to clear.\r\n\t */\r\n\tpublic void clearBodyPart(int part) {\r\n\t\tthis.bodyParts[part] = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Prepares the data used for the appearance update mask.\r\n\t * @param player The player.\r\n\t */\r\n\tpublic void prepareBodyData(Player player) {\r\n\t\tif (player.getRenderInfo().preparedAppearance()) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayer.getRenderInfo().setPreparedAppearance(true);\r\n\t\tItem chest = player.getEquipment().get(EquipmentContainer.SLOT_CHEST);\r\n\t\tItem shield = player.getEquipment().get(EquipmentContainer.SLOT_SHIELD);\r\n\t\tItem legs = player.getEquipment().get(EquipmentContainer.SLOT_LEGS);\r\n\t\tItem hat = player.getEquipment().get(EquipmentContainer.SLOT_HAT);\r\n\t\tItem hands = player.getEquipment().get(EquipmentContainer.SLOT_HANDS);\r\n\t\tItem feet = player.getEquipment().get(EquipmentContainer.SLOT_FEET);\r\n\t\tItem cape = player.getEquipment().get(EquipmentContainer.SLOT_CAPE);\r\n\t\tItem amulet = player.getEquipment().get(EquipmentContainer.SLOT_AMULET);\r\n\t\tItem weapon = player.getEquipment().get(EquipmentContainer.SLOT_WEAPON);\r\n\t\tboolean castleWarsHood = cape != null && (cape.getId() == 4041 || cape.getId() == 4042); // Item\r\n\t\tif (hat != null) {\r\n\t\t\tdrawItem(0, hat);\r\n\t\t} else {\r\n\t\t\tclearBodyPart(0);\r\n\t\t}\r\n\t\tif (cape != null) {\r\n\t\t\tdrawItem(1, cape);\r\n\t\t} else {\r\n\t\t\tclearBodyPart(1);\r\n\t\t}\r\n\t\tif (amulet != null) {\r\n\t\t\tdrawItem(2, amulet);\r\n\t\t} else {\r\n\t\t\tclearBodyPart(2);\r\n\t\t}\r\n\t\tif (!ridingMinecart) {\r\n\t\t\tif (weapon != null) {\r\n\t\t\t\tdrawItem(3, weapon);\r\n\t\t\t} else {\r\n\t\t\t\tclearBodyPart(3);\r\n\t\t\t}\r\n\t\t\tif (shield != null) {\r\n\t\t\t\tdrawItem(5, shield);\r\n\t\t\t} else {\r\n\t\t\t\tclearBodyPart(5);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tclearBodyPart(5);\r\n\t\t\tdrawClothes(3, 82);\r\n\t\t}\r\n\t\tif (chest != null) {\r\n\t\t\tdrawItem(4, chest);\r\n\t\t} else {\r\n\t\t\tdrawClothes(4, getTorso().getLook());\r\n\t\t}\r\n\t\tif (chest != null && chest.getDefinition().getConfiguration(ItemConfigParser.REMOVE_SLEEVES, false)) {\r\n\t\t\tclearBodyPart(6);\r\n\t\t} else {\r\n\t\t\tdrawClothes(6, getArms().getLook());\r\n\t\t}\r\n\t\tif (legs != null) {\r\n\t\t\tdrawItem(7, legs);\r\n\t\t} else {\r\n\t\t\tdrawClothes(7, getLegs().getLook());\r\n\t\t}\r\n\t\tif ((hat != null && hat.getDefinition().getConfiguration(ItemConfigParser.REMOVE_HEAD, false)) || castleWarsHood) {\r\n\t\t\tclearBodyPart(8);\r\n\t\t} else {\r\n\t\t\tdrawClothes(8, getHair().getLook());\r\n\t\t}\r\n\t\tif (hands != null) {\r\n\t\t\tdrawItem(9, hands);\r\n\t\t} else {\r\n\t\t\tdrawClothes(9, getWrists().getLook());\r\n\t\t}\r\n\t\tif (feet != null) {\r\n\t\t\tdrawItem(10, feet);\r\n\t\t} else {\r\n\t\t\tdrawClothes(10, getFeet().getLook());\r\n\t\t}\r\n\t\tif (hat != null && hat.getDefinition().getConfiguration(ItemConfigParser.REMOVE_BEARD, false)) {\r\n\t\t\tclearBodyPart(11);\r\n\t\t} else {\r\n\t\t\tdrawClothes(11, getBeard().getLook());\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Rides a mine cart.\r\n\t */\r\n\tpublic void rideCart(boolean ride) {\r\n\t\tif (!ride) {\r\n\t\t\tsetAnimations();\r\n\t\t} else {\r\n\t\t\tplayer.getAppearance().setAnimations(Animation.create(2148));\r\n\t\t}\r\n\t\tplayer.getAppearance().setRidingMinecart(ride);\r\n\t\tplayer.getAppearance().sync();\r\n\t}\r\n\r\n\t/**\r\n\t * Flys a gnome copter.\r\n\t */\r\n\tpublic void flyCopter() {\r\n\t\tplayer.animate(Animation.create(8956));\r\n\t\tplayer.getEquipment().replace(new Item(12842), 3);\r\n\t\tplayer.getAppearance().setStandAnimation(8964);\r\n\t\tplayer.getAppearance().setWalkAnimation(8961);\r\n\t\tplayer.getAppearance().setRunAnimation(8963);\r\n\t\tplayer.getAppearance().setTurn180(8963);\r\n\t\tplayer.getAppearance().setTurn90ccw(8963);\r\n\t\tplayer.getAppearance().setTurn90cw(8963);\r\n\t\tplayer.getAppearance().setStandTurnAnimation(8963);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the player.\r\n\t * @return The player.\r\n\t */\r\n\tpublic Player getPlayer() {\r\n\t\treturn player;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the hair body part.\r\n\t * @return the hair.\r\n\t */\r\n\tpublic BodyPart getHair() {\r\n\t\treturn appearanceCache[AppearanceCache.HAIR];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the beard body part.\r\n\t * @return the beard.\r\n\t */\r\n\tpublic BodyPart getBeard() {\r\n\t\treturn appearanceCache[AppearanceCache.FACIAL_HAIR];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the torso body part.\r\n\t * @return the torso.\r\n\t */\r\n\tpublic BodyPart getTorso() {\r\n\t\treturn appearanceCache[AppearanceCache.TORSO];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the arms body part.\r\n\t * @return the body part.\r\n\t */\r\n\tpublic BodyPart getArms() {\r\n\t\treturn appearanceCache[AppearanceCache.ARMS];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the wrist part part.\r\n\t * @return the body part.\r\n\t */\r\n\tpublic BodyPart getWrists() {\r\n\t\treturn appearanceCache[AppearanceCache.WRISTS];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the skin part.\r\n\t * @return the part.\r\n\t */\r\n\tpublic BodyPart getSkin() {\r\n\t\treturn appearanceCache[AppearanceCache.WRISTS];\r\n\t}\r\n\r\n\t/**\r\n\t * Getsthe leg body parts.\r\n\t * @return the legs.\r\n\t */\r\n\tpublic BodyPart getLegs() {\r\n\t\treturn appearanceCache[AppearanceCache.LEGS];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the feet body parts.\r\n\t * @return the feet.\r\n\t */\r\n\tpublic BodyPart getFeet() {\r\n\t\treturn appearanceCache[AppearanceCache.FEET];\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the stand animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getStandAnimation() {\r\n\t\treturn animationCache[0];\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to set the stand animation.\r\n\t * @param animation\r\n\t */\r\n\tpublic void setStandAnimation(int animation) {\r\n\t\tanimationCache[0] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the standing turn animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getStandTurnAnimation() {\r\n\t\treturn animationCache[1];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the standing turn animation.\r\n\t */\r\n\tpublic void setStandTurnAnimation(int animation) {\r\n\t\tanimationCache[1] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the walk animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getWalkAnimation() {\r\n\t\treturn animationCache[2];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the walk animation.\r\n\t * @param animation the animation.\r\n\t */\r\n\tpublic void setWalkAnimation(int animation) {\r\n\t\tanimationCache[2] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the turning 180 animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getTurn180() {\r\n\t\treturn animationCache[3];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the tunring 180 animation.\r\n\t * @param animation the animation.\r\n\t */\r\n\tpublic void setTurn180(int animation) {\r\n\t\tanimationCache[3] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the turn90cw animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getTurn90cw() {\r\n\t\treturn animationCache[4];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the turn90cw animation.\r\n\t * @param animation the animation.\r\n\t */\r\n\tpublic void setTurn90cw(int animation) {\r\n\t\tanimationCache[4] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the turn90ccw animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getTurn90ccw() {\r\n\t\treturn animationCache[5];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets thr turn90cww animation.\r\n\t * @param animation\r\n\t */\r\n\tpublic void setTurn90ccw(int animation) {\r\n\t\tanimationCache[5] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the run animation.\r\n\t * @return the animation.\r\n\t */\r\n\tpublic int getRunAnimation() {\r\n\t\treturn animationCache[6];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the running animation.\r\n\t * @param animation the animation.\r\n\t */\r\n\tpublic void setRunAnimation(int animation) {\r\n\t\tanimationCache[6] = animation;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the render animation id.\r\n\t * @return The render animation id.\r\n\t */\r\n\tpublic int getRenderAnimation() {\r\n\t\treturn renderAnimationId;\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to set the default animations.\r\n\t */\r\n\tpublic void setDefaultAnimations() {\r\n\t\tfor (int i = 0; i < animationCache.length; i++) {\r\n\t\t\tanimationCache[i] = AppearanceCache.ANIMATIONS[i];\r\n\t\t}\r\n\t\trenderAnimationId = 1426;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the skull icon.\r\n\t * @return the icon.\r\n\t */\r\n\tpublic int getSkullIcon() {\r\n\t\treturn iconCache[0];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the skull icon.\r\n\t * @param icon the icon.\r\n\t */\r\n\tpublic void setSkullIcon(int icon) {\r\n\t\ticonCache[0] = icon;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the head icon.\r\n\t * @return the icon.\r\n\t */\r\n\tpublic int getHeadIcon() {\r\n\t\treturn iconCache[1];\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the head icon.\r\n\t * @param icon the icon.\r\n\t */\r\n\tpublic void setHeadIcon(int icon) {\r\n\t\tthis.iconCache[1] = icon;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the gender.\r\n\t * @return The gender.\r\n\t */\r\n\tpublic Gender getGender() {\r\n\t\treturn gender;\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to change the gender of a player.\r\n\t * @param gender the gender.\r\n\t */\r\n\tpublic void changeGender(Gender gender) {\r\n\t\tsetGender(gender);\r\n\t\tsync();\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to set the gender.\r\n\t * @param gender the gender.\r\n\t */\r\n\tpublic void setGender(final Gender gender) {\r\n\t\tthis.gender = gender;\r\n\t\tthis.appearanceCache = gender.generateCache();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the value {@code True} if male.\r\n\t * @return {@code True} if so.\r\n\t */\r\n\tpublic boolean isMale() {\r\n\t\treturn gender == Gender.MALE;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the npc id.\r\n\t * @return the npc id.\r\n\t */\r\n\tpublic int getNpcId() {\r\n\t\treturn npcId;\r\n\t}\r\n\r\n\t/**\r\n\t * If the player's appearance is a NPC.\r\n\t * @return If the player's appearance is a NPC {@code true}.\r\n\t */\r\n\tpublic boolean isNpc() {\r\n\t\treturn npcId != -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the appearanceCache.\r\n\t * @return The appearanceCache.\r\n\t */\r\n\tpublic BodyPart[] getAppearanceCache() {\r\n\t\treturn appearanceCache;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the animationCache.\r\n\t * @return The animationCache.\r\n\t */\r\n\tpublic int[] getAnimationCache() {\r\n\t\treturn animationCache;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the bodyParts.\r\n\t * @return The bodyParts.\r\n\t */\r\n\tpublic int[] getBodyParts() {\r\n\t\treturn bodyParts;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the ridingMinecart.\r\n\t * @return The ridingMinecart.\r\n\t */\r\n\tpublic boolean isRidingMinecart() {\r\n\t\treturn ridingMinecart;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the ridingMinecart.\r\n\t * @param ridingMinecart The ridingMinecart to set.\r\n\t */\r\n\tpublic void setRidingMinecart(boolean ridingMinecart) {\r\n\t\tthis.ridingMinecart = ridingMinecart;\r\n\t}\r\n\r\n\t/**\r\n\t * Represents a class of cached appearance related information.\r\n\t * @author 'Vexia\r\n\t */\r\n\tpublic static class AppearanceCache {\r\n\r\n\t\t/**\r\n\t\t * Represents the appearance animations.\r\n\t\t */\r\n\t\tpublic static final int[] ANIMATIONS = new int[] { 0x328, 0x337, 0x333, 0x334, 0x335, 0x336, 0x338 };\r\n\r\n\t\t/**\r\n\t\t * Represents the index hair apperance is cached at.\r\n\t\t */\r\n\t\tpublic static final int HAIR = 0;\r\n\r\n\t\t/**\r\n\t\t * Represents the index facial hair appearance is cached at.\r\n\t\t */\r\n\t\tpublic static final int FACIAL_HAIR = 1;\r\n\r\n\t\t/**\r\n\t\t * Represents the index torso appearance is cached at.\r\n\t\t */\r\n\t\tpublic static final int TORSO = 2;\r\n\r\n\t\t/**\r\n\t\t * Represents the index arm appearance is cached at.\r\n\t\t */\r\n\t\tpublic static final int ARMS = 3;\r\n\r\n\t\t/**\r\n\t\t * Represents the index wrist appearance is cached at.\r\n\t\t */\r\n\t\tpublic static final int WRISTS = 4;\r\n\r\n\t\t/**\r\n\t\t * Represents the index leg appearance is cached at.\r\n\t\t */\r\n\t\tpublic static final int LEGS = 5;\r\n\r\n\t\t/**\r\n\t\t * Represents the index feet appearance is cached at.\r\n\t\t */\r\n\t\tpublic static final int FEET = 6;\r\n\r\n\t\t/**\r\n\t\t * Represents the index hair color is cached at.\r\n\t\t */\r\n\t\tpublic static final int HAIR_COLOR = 0;\r\n\r\n\t\t/**\r\n\t\t * Represents the index torso color is cached at.\r\n\t\t */\r\n\t\tpublic static final int TORSO_COLOR = 1;\r\n\r\n\t\t/**\r\n\t\t * Represents the index leg color is cached at.\r\n\t\t */\r\n\t\tpublic static final int LEG_COLOR = 2;\r\n\r\n\t\t/**\r\n\t\t * Represents the index feet color is cached at.\r\n\t\t */\r\n\t\tpublic static final int FEET_COLOR = 3;\r\n\r\n\t\t/**\r\n\t\t * Represents the index skin color is cached at.\r\n\t\t */\r\n\t\tpublic static final int SKIN_COLOR = 4;\r\n\r\n\t\t/**\r\n\t\t * The player's stand animation.\r\n\t\t */\r\n\t\tprivate static final int STAND_ANIM = 0x328;\r\n\r\n\t\t/**\r\n\t\t * The player's turn animation for standing.\r\n\t\t */\r\n\t\tprivate static final int STAND_TURN_ANIM = 0x337;\r\n\r\n\t\t/**\r\n\t\t * The player's walk animation.\r\n\t\t */\r\n\t\tpublic static final int WALK_ANIM = 0x333;\r\n\r\n\t\t/**\r\n\t\t * The player's turn 180 degrees animation.\r\n\t\t */\r\n\t\tprivate static final int TURN_180_AIM = 0x334;\r\n\r\n\t\t/**\r\n\t\t * The player's turn 90 degrees animation.\r\n\t\t */\r\n\t\tprivate static final int TURN_90_CW = 0x335;\r\n\r\n\t\t/**\r\n\t\t * The player's turn 90 degrees animation.\r\n\t\t */\r\n\t\tprivate static final int TUNR_90_CWW = 0x336;\r\n\r\n\t\t/**\r\n\t\t * The player's run animation.\r\n\t\t */\r\n\t\tprivate static final int RUN_ANIM = 0x338;\r\n\r\n\t}\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Server/src/main/java/Server/core/game/node/entity/player/link/appearance/Appearance.java	(revision 0eaf93649d735b04d0ae8059a6b71fa9a98f6cb8)
+++ Server/src/main/java/Server/core/game/node/entity/player/link/appearance/Appearance.java	(date 1597090309767)
@@ -92,6 +92,14 @@
 		}
 	}
 
+	public void parse(JSONObject appearance){
+		gender = gender.asByte(Byte.parseByte(appearance.get("gender").toString()));
+		JSONArray appCache = (JSONArray) appearance.get("appearance_cache");
+		for(int i = 0; i < appearanceCache.length; i++){
+			(appearanceCache[i]).parse((JSONObject) appCache.get(i));
+		}
+	}
+
 	@Override
 	public void parse(ByteBuffer buffer) {
 		gender = gender.asByte(buffer.get());
Index: Server/src/main/java/Server/plugin/skill/farming/FarmingEquipment.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package plugin.skill.farming;\r\n\r\nimport core.game.component.CloseEvent;\r\nimport core.game.component.Component;\r\nimport core.game.container.Container;\r\nimport core.game.container.ContainerType;\r\nimport core.game.content.ItemNames;\r\nimport core.game.node.entity.player.Player;\r\nimport core.game.node.entity.player.info.login.SavingModule;\r\nimport core.game.node.item.Item;\r\n\r\nimport java.nio.ByteBuffer;\r\n\r\n/**\r\n * Represents a managing class used for farming equipment.\r\n * @author Vexia\r\n */\r\npublic final class FarmingEquipment implements SavingModule {\r\n\r\n\t/**\r\n\t * Represents the items to use in the store.\r\n\t */\r\n\tprivate static final Item[] ITEMS = new Item[] {\r\n\t\t\tnew Item(ItemNames.RAKE_5341),\r\n\t\t\tnew Item(ItemNames.SEED_DIBBER_5343),\r\n\t\t\tnew Item(ItemNames.SPADE_952),\r\n\t\t\tnew Item(ItemNames.SECATEURS_5329),\r\n\t\t\tnew Item(ItemNames.WATERING_CAN_5331),\r\n\t\t\tnew Item(ItemNames.GARDENING_TROWEL),\r\n\t\t\tnew Item(ItemNames.BUCKET_1925),\r\n\t\t\tnew Item(ItemNames.COMPOST_6032),\r\n\t\t\tnew Item(ItemNames.SUPERCOMPOST_6034)\r\n\t};\r\n\r\n\t/**\r\n\t * Represents the watering cans.\r\n\t */\r\n\tprivate static final Item[] WATERING_CANS = new Item[] { new Item(5340), new Item(5339), new Item(5338), new Item(5337), new Item(5336), new Item(5335), new Item(5334), new Item(5333), new Item(5331) };\r\n\r\n\t/**\r\n\t * Types of storable secateurs\r\n\t */\r\n\tprivate static final Item[] SECATEURS = new Item[] { new Item(ItemNames.MAGIC_SECATEURS_7409), new Item(ItemNames.SECATEURS_5329) };\r\n\r\n\t/**\r\n\t * Represents the equipment store component.\r\n\t */\r\n\tprivate static final Component STORE_COMPONENT = new Component(125).setCloseEvent(new StoreCloseEvent());\r\n\r\n\t/**\r\n\t * Represents the tab component.\r\n\t */\r\n\tprivate static final Component TAB_COMPONENT = new Component(126);\r\n\r\n\t/**\r\n\t * Represents the config used for the store.\r\n\t */\r\n\tprivate static final int CONFIG = 615;\r\n\r\n\t/**\r\n\t * Represents the container.\r\n\t */\r\n\tprivate final Container container = new Container(9, ContainerType.ALWAYS_STACK);\r\n\r\n\t@Override\r\n\tpublic void save(ByteBuffer buffer) {\r\n\t\tcontainer.save(buffer);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void parse(ByteBuffer buffer) {\r\n\t\tcontainer.parse(buffer);\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to open the equipment store.\r\n\t * @param player the player.\r\n\t */\r\n\tpublic void open(final Player player) {\r\n\t\tplayer.getInterfaceManager().open(STORE_COMPONENT);\r\n\t\tplayer.getInterfaceManager().openSingleTab(TAB_COMPONENT);\r\n\t\tupdate(player);\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to store an item from a slot.\r\n\t * @param player the player.\r\n\t * @param slot the slot.\r\n\t * @param amount the amount.\r\n\t * @return {@code True} if stored.\r\n\t */\r\n\tpublic boolean store(final Player player, final int slot, int amount) {\r\n\t\tfinal String name = getItemName(slot);\r\n\t\tif (!hasItem(player, slot, false)) {\r\n\t\t\tplayer.getPacketDispatch().sendMessage(\"You haven't got \" + (name.equals(\"secateurs\") || name.equals(\"supercompost\") || name.equals(\"compost\") ? \"any \" : \"a \") + name + \" to store.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfinal int inventoryAmount = player.getInventory().getAmount(slot == 3 ? new Item(getSecateurs(player).getId(), 1) : slot == 4 ? new Item(getWateringCan(player).getId(), 1) : ITEMS[slot]);\r\n\t\tif (amount > inventoryAmount) {\r\n\t\t\tamount = inventoryAmount;\r\n\t\t}\r\n\t\tif (amount > getMaxAdd(slot)) {\r\n\t\t\tamount = getMaxAdd(slot);\r\n\t\t}\r\n\t\tif ((getEquipmentAmount(slot) + amount) > getMaxAdd(slot)) {\r\n\t\t\tplayer.getPacketDispatch().sendMessage(\"You cannot store more than \" + getAddName(slot) + \" \" + name + (getMaxAdd(slot) > 1 ? \"s\" : \"\") + \" in here.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tfinal Item item = slot == 3 ? new Item(getSecateurs(player).getId(), amount) : slot == 4 ? new Item(getWateringCan(player).getId(), amount) : new Item(ITEMS[slot].getId(), amount);\r\n\t\tif (player.getInventory().remove(item)) {\r\n\t\t\tif (slot >= 6) {\r\n\t\t\t\tint oldAmt = container.getAmount(item);\r\n\t\t\t\tcontainer.replace(new Item(item.getId(), item.getAmount() + oldAmt), slot, true);\r\n\t\t\t} else {\r\n\t\t\t\tcontainer.replace(new Item(item.getId(), item.getAmount()), slot, true);\r\n\t\t\t}\r\n\t\t\tupdate(player);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to remove an item from your equipment store.\r\n\t * @param player the player.\r\n\t * @param slot the slot.\r\n\t * @param amount the amount.\r\n\t * @return {@code True} if removed.\r\n\t */\r\n\tpublic boolean remove(final Player player, final int slot, int amount) {\r\n\t\tfinal String name = getItemName(slot);\r\n\t\tif (!hasItem(player, slot, true)) {\r\n\t\t\tplayer.getPacketDispatch().sendMessage(\"You haven't got \" + (name.equals(\"secateurs\") || name.equals(\"supercompost\") || name.equals(\"compost\") ? \"any \" : \"a \") + name + \" stored in here.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (amount == 0) {\r\n\t\t\tamount = getEquipmentAmount(slot);\r\n\t\t}\r\n\t\tif (amount > getEquipmentAmount(slot)) {\r\n\t\t\tamount = getEquipmentAmount(slot);\r\n\t\t}\r\n\t\tfinal Item item = new Item(container.get(slot).getId(), amount);\r\n\t\tif (!player.getInventory().hasSpaceFor(item)) {\r\n\t\t\tplayer.getPacketDispatch().sendMessage(\"You don't have room to hold that.\");\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tif (player.getInventory().add(item)) {\r\n\t\t\tcontainer.remove(item);\r\n\t\t\tupdate(player);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t/**\r\n\t * Method used to update the interface.\r\n\t * @param player the player.\r\n\t */\r\n\tprivate void update(final Player player) {\r\n\t\tplayer.getConfigManager().set(CONFIG, getConfigHash());\r\n\t\tplayer.getConfigManager().get(CONFIG);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the config hash.\r\n\t * @return the config hash.\r\n\t */\r\n\tprivate int getConfigHash() {\r\n\t\tint hash = getEquipmentAmount(0);\r\n\t\thash |= getEquipmentAmount(1) << 1;\r\n\t\thash |= getEquipmentAmount(2) << 2;\r\n\t\thash |= getEquipmentAmount(3) << 3;\r\n\t\thash |= getCanIndex() << 4;\r\n\t\thash |= getEquipmentAmount(5) << 8;\r\n\t\thash |= getEquipmentAmount(6) << 9;\r\n\t\thash |= getEquipmentAmount(7) << 14;\r\n\t\thash |= getEquipmentAmount(8) << 22;\r\n\t\thash |= getSecateursMagic() ? 1 << 30 : 0; // magic secateurs bit\r\n\t\treturn hash;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the amount on a slot.\r\n\t * @param slot the slot.\r\n\t * @return the equipment.\r\n\t */\r\n\tpublic int getEquipmentAmount(int slot) {\r\n\t\tfinal Item i = container.get(slot);\r\n\t\treturn i == null ? 0 : i.getAmount();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the inventory amount.\r\n\t * @param player the player.\r\n\t * @param slot the slot.\r\n\t * @return the inventory amount.\r\n\t */\r\n\tpublic int getInventoryAmount(final Player player, int slot) {\r\n\t\tif (slot == 3) {\r\n\t\t\treturn player.getInventory().getAmount(getSecateurs(player));\r\n\t\t}\r\n\t\tif (slot == 4) {\r\n\t\t\treturn player.getInventory().getAmount(getWateringCan(player));\r\n\t\t}\r\n\t\tif (slot < 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn player.getInventory().getAmount(ITEMS[slot]);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the maximum add of an item to a slot.\r\n\t * @param slot the slot..\r\n\t * @return the maximum amt allowed to be added.\r\n\t */\r\n\tpublic int getMaxAdd(int slot) {\r\n\t\treturn slot < 6 ? 1 : slot == 6 ? 31 : 255;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the add name.\r\n\t * @param slot the slot.\r\n\t * @return the add name.\r\n\t */\r\n\tprivate String getAddName(int slot) {\r\n\t\treturn slot < 6 ? \"one\" : slot == 6 ? \"thirty one\" : \"two hundred fifty five\";\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the player has the item.\r\n\t * @param player the player.two hundred andtwo hundred fifty f\r\n\t * @param slot the slot.\r\n\t * @param store the store.\r\n\t * @return {@code True} if so.\r\n\t */\r\n\tprivate boolean hasItem(final Player player, int slot, final boolean store) {\r\n\t\treturn store ? container.get(slot) != null : getInventoryAmount(player, slot) != 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the can index.\r\n\t * @return the index.\r\n\t */\r\n\tprivate int getCanIndex() {\r\n\t\tint canIndex = 0;\r\n\t\tfor (int i = 0; i < WATERING_CANS.length; i++) {\r\n\t\t\tif (container.get(4) == null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tif (container.get(4).getId() == WATERING_CANS[i].getId()) {\r\n\t\t\t\tcanIndex = 9 - i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn canIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets whether stored secateurs are magic or not\r\n\t */\r\n\tprivate boolean getSecateursMagic() {\r\n\t\treturn container.get(3) == null ? false : (container.get(3).getId() == ItemNames.MAGIC_SECATEURS_7409);\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the formated item name.\r\n\t * @param slot the slot.\r\n\t * @return the name.\r\n\t */\r\n\tprivate String getItemName(int slot) {\r\n\t\tif (slot == 4) {\r\n\t\t\treturn \"watering can\";\r\n\t\t}\r\n\t\tif (slot < 0) {\r\n\t\t\treturn \"report me\";\r\n\t\t}\r\n\t\treturn ITEMS[slot].getName().toLowerCase();\r\n\t}\r\n\r\n\t/**\r\n\t * Gets thes watering can to store.\r\n\t * @param player the player.\r\n\t * @return the item.\r\n\t */\r\n\tprivate Item getWateringCan(final Player player) {\r\n\t\tfor (Item i : WATERING_CANS) {\r\n\t\t\tif (player.getInventory().containsItem(i)) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets secateurs type from inventory to store\r\n\t */\r\n\tprivate Item getSecateurs(final Player player) {\r\n\t\tfor (Item i : SECATEURS) {\r\n\t\t\tif (player.getInventory().containsItem((i))) {\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the container.\r\n\t * @return The container.\r\n\t */\r\n\tpublic Container getContainer() {\r\n\t\treturn container;\r\n\t}\r\n\r\n\t/**\r\n\t * Represents the close event of the equipment store.\r\n\t * @author 'Vexia\r\n\t * @version 1.0\r\n\t */\r\n\tpublic static final class StoreCloseEvent implements CloseEvent {\r\n\r\n\t\t@Override\r\n\t\tpublic boolean close(Player player, Component c) {\r\n\t\t\tplayer.getInterfaceManager().closeSingleTab();\r\n\t\t\tplayer.getPacketDispatch().sendRunScript(101, \"\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t}\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- Server/src/main/java/Server/plugin/skill/farming/FarmingEquipment.java	(revision 0eaf93649d735b04d0ae8059a6b71fa9a98f6cb8)
+++ Server/src/main/java/Server/plugin/skill/farming/FarmingEquipment.java	(date 1597090310207)
@@ -303,6 +303,18 @@
 		return null;
 	}
 
+	/**
+	 * Gets secateurs type from inventory to store
+	 */
+	private Item getSecateurs(final Player player) {
+		for (Item i : SECATEURS) {
+			if (player.getInventory().containsItem((i))) {
+				return i;
+			}
+		}
+		return null;
+	}
+
 	/**
 	 * Gets the container.
 	 * @return The container.
